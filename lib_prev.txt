use anchor_lang::prelude::*;
use anchor_spl::token::{self, Mint, Token, TokenAccount, Transfer, InitializeAccount};

declare_id!("5V4D1b9wrjuJC3aAtNbayVgMYt5879w2rL2k5UoQGTvM");

#[program]
pub mod energy_auction {
    use super::*;

    /// Initialize the global protocol state
    pub fn init_global_state(
        ctx: Context<InitGlobalState>,
        fee_bps: u16,
        version: u8,
    ) -> Result<()> {
        require!(fee_bps <= 10_000, EnergyAuctionError::ConstraintViolation);

        let state = &mut ctx.accounts.global_state;
        state.authority = ctx.accounts.authority.key();
        state.fee_bps = fee_bps;
        state.version = version;
        state.quote_mint = ctx.accounts.quote_mint.key();
        state.fee_vault = ctx.accounts.fee_vault.key();

        Ok(())
    }

    /// Open a new auction timeslot
    pub fn open_timeslot(
        ctx: Context<OpenTimeslot>,
        epoch_ts: i64,
        lot_size: u64,
        price_tick: u64,
    ) -> Result<()> {
        // only protocol authority may open
        require_keys_eq!(
            ctx.accounts.global_state.authority,
            ctx.accounts.authority.key(),
            EnergyAuctionError::InvalidAuthority
        );
        require!(lot_size > 0, EnergyAuctionError::ConstraintViolation);
        require!(price_tick > 0, EnergyAuctionError::ConstraintViolation);

        let slot = &mut ctx.accounts.timeslot;
        slot.epoch_ts = epoch_ts;
        slot.status = TimeslotStatus::Open as u8; // Open
        slot.lot_size = lot_size;
        slot.quote_mint = ctx.accounts.global_state.quote_mint;
        slot.price_tick = price_tick;
        slot.total_supply = 0;
        slot.total_bids = 0;
        slot.head_page = None;
        slot.tail_page = None;
        Ok(())
    }

    /// Seller commits supply (one-time per (global_state, timeslot, seller))
    /// Escrows seller's energy tokens into a program-owned vault (authority = timeslot PDA)
    pub fn commit_supply(
        ctx: Context<CommitSupply>,
        _timeslot_epoch: i64, // kept for seed consistency in IDL
        reserve_price: u64,
        quantity: u64,
    ) -> Result<()> {
        let supply = &mut ctx.accounts.supply;
        require!(quantity > 0, EnergyAuctionError::ConstraintViolation);
        require!(matches!(ctx.accounts.timeslot.status(), TimeslotStatus::Open), EnergyAuctionError::InvalidTimeslot);

        // initialize supply account fields (immutable after init)
        supply.supplier = ctx.accounts.signer.key();
        supply.timeslot = ctx.accounts.timeslot.key();
        supply.amount = quantity;
        supply.reserve_price = reserve_price;
        supply.bump = ctx.bumps.supply;
        supply.energy_mint = ctx.accounts.energy_mint.key();
        supply.escrow_vault = ctx.accounts.seller_escrow.key();

        // transfer energy tokens from seller to escrow (authority = signer)
        let cpi_ctx = CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.seller_source.to_account_info(),
                to: ctx.accounts.seller_escrow.to_account_info(),
                authority: ctx.accounts.signer.to_account_info(),
            },
        );
        token::transfer(cpi_ctx, quantity)?;

        // bump total supply on timeslot
        let ts = &mut ctx.accounts.timeslot;
        ts.total_supply = ts
            .total_supply
            .checked_add(quantity)
            .ok_or(EnergyAuctionError::MathError)?;

        emit!(SupplyCommitted {
            supplier: supply.supplier,
            timeslot: ts.epoch_ts as u64,
            amount: quantity,
        });

        Ok(())
    }

    /// Buyer places bid, escrows quote tokens (USDC) into a program-owned vault (authority = timeslot PDA)
    /// Buyer places bid, escrows quote tokens (USDC) into a program-owned vault (authority = timeslot PDA)
pub fn place_bid(
    ctx: Context<PlaceBid>,
    price: u64,
    quantity: u64,
    timestamp: i64,
) -> Result<()> {
    let ts = &mut ctx.accounts.timeslot;

    // ✅ validation checks
    require!(matches!(ts.status(), TimeslotStatus::Open), EnergyAuctionError::InvalidTimeslot);
    require!(price > 0 && quantity > 0, EnergyAuctionError::ConstraintViolation);
    require!(price % ts.price_tick == 0, EnergyAuctionError::ConstraintViolation);

    // ✅ compute escrow transfer amount = price * quantity
    let amount_u128 = (price as u128)
        .checked_mul(quantity as u128)
        .ok_or(EnergyAuctionError::MathError)?;
    let amount = u64::try_from(amount_u128).map_err(|_| EnergyAuctionError::MathError)?;

    // ✅ transfer USDC into escrow vault
    let cpi_ctx = CpiContext::new(
        ctx.accounts.token_program.to_account_info(),
        Transfer {
            from: ctx.accounts.buyer_source.to_account_info(),
            to: ctx.accounts.timeslot_quote_escrow.to_account_info(),
            authority: ctx.accounts.buyer.to_account_info(),
        },
    );
    token::transfer(cpi_ctx, amount)?;

    // ✅ select target page: use tail_page if not full, else new_page
    let page = ctx
        .accounts
        .tail_page
        .as_deref_mut()
        .filter(|p| p.bids.len() < BidPage::MAX_BIDS)
        .or_else(|| ctx.accounts.new_page.as_deref_mut())
        .ok_or(EnergyAuctionError::ConstraintViolation)?;

    // ✅ push new bid into chosen page
    page.bids.push(Bid {
        owner: ctx.accounts.buyer.key(),
        price,
        quantity,
        timestamp,
        status: BidStatus::Active as u8,
    });

    // ✅ update timeslot bid count
    ts.total_bids = ts
        .total_bids
        .checked_add(quantity)
        .ok_or(EnergyAuctionError::MathError)?;

    Ok(())
}



    /// Seal a timeslot (freeze order flow)
    pub fn seal_timeslot(ctx: Context<SealTimeslot>) -> Result<()> {
        require_keys_eq!(
            ctx.accounts.global_state.authority,
            ctx.accounts.authority.key(),
            EnergyAuctionError::InvalidAuthority
        );
        let ts = &mut ctx.accounts.timeslot;
        require!(matches!(ts.status(), TimeslotStatus::Open), EnergyAuctionError::InvalidTimeslot);
        ts.status = TimeslotStatus::Sealed as u8;
        Ok(())
    }

    // TODO:
    // - clear_and_settle
    // - withdraw_proceeds
    // - withdraw_refund
    // - redeem_energy
}

///////////////////////
// Contexts
///////////////////////

#[derive(Accounts)]
pub struct InitGlobalState<'info> {
    #[account(
        init,
        payer = authority,
        space = 8 + GlobalState::LEN,
        seeds = [b"global_state"],
        bump
    )]
    pub global_state: Account<'info, GlobalState>,

    pub quote_mint: Account<'info, Mint>, // USDC or quote token

    #[account(
        init,
        payer = authority,
        token::mint = quote_mint,
        token::authority = global_state,
        seeds = [b"fee_vault"],
        bump
    )]
    pub fee_vault: Account<'info, TokenAccount>,

    #[account(mut)]
    pub authority: Signer<'info>,

    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
}

/// OpenTimeslot: creates a timeslot PDA
#[derive(Accounts)]
#[instruction(epoch_ts: i64)]
pub struct OpenTimeslot<'info> {
    #[account(mut)]
    pub global_state: Account<'info, GlobalState>,

    #[account(
        init,
        payer = authority,
        space = 8 + Timeslot::LEN,
        seeds = [b"timeslot", &epoch_ts.to_le_bytes()],
        bump
    )]
    pub timeslot: Account<'info, Timeslot>,

    #[account(mut)]
    pub authority: Signer<'info>, // must equal global_state.authority

    pub system_program: Program<'info, System>,
}

/// Seller commits supply for a specific timeslot (one-time)
#[derive(Accounts)]
#[instruction(_timeslot_epoch: i64)]
pub struct CommitSupply<'info> {
    /// Global protocol state
    pub global_state: Account<'info, GlobalState>,

    /// Timeslot must be Open
    #[account(mut,
        seeds = [b"timeslot", &timeslot.epoch_ts.to_le_bytes()],
        bump,
    )]
    pub timeslot: Account<'info, Timeslot>,

    /// PDA: ("supply", timeslot, signer)
    #[account(
        init,
        payer = signer,
        space = 8 + Supply::LEN,
        seeds = [b"supply", timeslot.key().as_ref(), signer.key().as_ref()],
        bump
    )]
    pub supply: Account<'info, Supply>,

    /// Energy mint (kWh token)
    pub energy_mint: Account<'info, Mint>,

    /// Seller's source ATA for energy tokens
    #[account(mut)]
    pub seller_source: Account<'info, TokenAccount>,

    /// Program-owned escrow TA for seller's energy (authority = timeslot PDA)
    #[account(
        init,
        payer = signer,
        token::mint = energy_mint,
        token::authority = timeslot,
        seeds = [b"seller_escrow", timeslot.key().as_ref(), signer.key().as_ref()],
        bump
    )]
    pub seller_escrow: Account<'info, TokenAccount>,

    /// Seller committing energy (payer & signer)
    #[account(mut)]
    pub signer: Signer<'info>,

    /// Programs
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
}

/// Buyer places a bid into an active bid page
#[derive(Accounts)]
pub struct PlaceBid<'info> {
    #[account(mut, has_one = quote_mint)]
    pub global_state: Account<'info, GlobalState>,

    #[account(mut)]
    pub timeslot: Account<'info, Timeslot>,

    #[account(mut)]
    pub timeslot_quote_escrow: Account<'info, TokenAccount>,

    pub quote_mint: Account<'info, Mint>,

    #[account(mut)]
    pub buyer_source: Account<'info, TokenAccount>,

    #[account(mut)]
    pub buyer: Signer<'info>,

    /// The last page of bids for this timeslot (if exists)
    #[account(mut)]
    pub tail_page: Option<Account<'info, BidPage>>,

    /// A newly created page if the old one is full
    #[account(
        init_if_needed,
        payer = buyer,
        space = BidPage::LEN,
        seeds = [b"bid_page", timeslot.key().as_ref(), &(timeslot.total_bids / 200).to_le_bytes()],
        bump
    )]
    pub new_page: Option<Account<'info, BidPage>>,

    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
}


#[derive(Accounts)]
pub struct SealTimeslot<'info> {
    pub global_state: Account<'info, GlobalState>,
    #[account(mut)]
    pub timeslot: Account<'info, Timeslot>,
    pub authority: Signer<'info>,
}

///////////////////////
// Events
///////////////////////

#[event]
pub struct SupplyCommitted {
    pub supplier: Pubkey,
    pub timeslot: u64,
    pub amount: u64,
}

///////////////////////
// State
///////////////////////

/// Global protocol config
#[account]
pub struct GlobalState {
    pub authority: Pubkey,   // protocol admin
    pub fee_bps: u16,        // protocol fee in basis points
    pub version: u8,         // versioning for upgrades
    pub quote_mint: Pubkey,  // e.g., USDC
    pub fee_vault: Pubkey,   // PDA token account for protocol fees
}

impl GlobalState {
    pub const LEN: usize = 32  // authority
        + 2                    // fee_bps
        + 1                    // version
        + 32                   // quote_mint
        + 32;                  // fee_vault
}

/// Minimal Supply struct for MVP (one-time immutable per timeslot)
#[account]
pub struct Supply {
    pub supplier: Pubkey,     // Who committed
    pub timeslot: Pubkey,     // timeslot account
    pub amount: u64,          // Amount committed (lots)
    pub reserve_price: u64,   // min acceptable price per lot (quote units)
    pub bump: u8,             // PDA bump
    pub energy_mint: Pubkey,  // energy token mint
    pub escrow_vault: Pubkey, // escrow token account for energy
}

impl Supply {
    pub const LEN: usize = 32 + 32 + 8 + 8 + 1 + 32 + 32;
}

/// Auction round container
#[account]
pub struct Timeslot {
    pub epoch_ts: i64,        // identifies auction window
    pub status: u8,           // Pending=0, Open=1, Sealed=2, Settled=3, Cancelled=4
    pub lot_size: u64,        // fixed per auction (1 kWh MVP)
    pub quote_mint: Pubkey,   // quote token (USDC)
    pub price_tick: u64,      // min price increment
    pub total_supply: u64,    // total committed lots
    pub total_bids: u64,      // total lots bid
    pub head_page: Option<Pubkey>, // linked list of BidPages
    pub tail_page: Option<Pubkey>, // last BidPage
}

impl Timeslot {
    pub const LEN: usize = 8   // epoch_ts
        + 1                   // status
        + 8                   // lot_size
        + 32                  // quote_mint
        + 8                   // price_tick
        + 8                   // total_supply
        + 8                   // total_bids
        + 1 + 32              // head_page (Option<Pubkey>)
        + 1 + 32;             // tail_page (Option<Pubkey>)

    pub fn status(&self) -> TimeslotStatus {
        match self.status {
            0 => TimeslotStatus::Pending,
            1 => TimeslotStatus::Open,
            2 => TimeslotStatus::Sealed,
            3 => TimeslotStatus::Settled,
            _ => TimeslotStatus::Cancelled,
        }
    }
}

#[repr(u8)]
pub enum TimeslotStatus {
    Pending = 0,
    Open = 1,
    Sealed = 2,
    Settled = 3,
    Cancelled = 4,
}

/// A single bid entry
#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct Bid {
    pub owner: Pubkey,
    pub price: u64,
    pub quantity: u64,
    pub timestamp: i64,
    pub status: u8, // Active=0, Cancelled=1, Filled=2
}

#[repr(u8)]
pub enum BidStatus { Active = 0, Cancelled = 1, Filled = 2 }

impl Bid {
    pub const LEN: usize = 32  // owner
        + 8                    // price
        + 8                    // quantity
        + 8                    // timestamp
        + 1;                   // status
}

/// Page of bids (linked list)
#[account]
pub struct BidPage {
    pub timeslot: Pubkey,         // which timeslot
    pub bids: Vec<Bid>,           // fixed max length (MVP: 200)
    pub next_page: Option<Pubkey>,
}

impl BidPage {
    pub const MAX_BIDS: usize = 200;
    pub const LEN: usize = 32                  // timeslot
        + 4 + (Bid::LEN * Self::MAX_BIDS)     // Vec<Bid>
        + 1 + 32;                             // next_page
}

/// Receipt created for each winning buyer after settlement
#[account]
pub struct FillReceipt {
    pub buyer: Pubkey,
    pub timeslot: Pubkey,
    pub quantity: u64,
    pub clearing_price: u64,
    pub redeemed: bool,
}

impl FillReceipt {
    pub const LEN: usize = 32  // buyer
        + 32                   // timeslot
        + 8                    // quantity
        + 8                    // clearing_price
        + 1;                   // redeemed
}

/// Protocol fee vault (separate from sellers’ escrows)
#[account]
pub struct FeeVault {
    pub bump: u8,              // PDA bump
    pub token_account: Pubkey, // SPL Token account PDA
}

impl FeeVault {
    pub const LEN: usize = 1 + 32;
}

#[error_code]
pub enum EnergyAuctionError {
    /// The provided authority does not match the global state authority
    #[msg("Invalid authority for this operation")]
    InvalidAuthority,

    /// Supply already exists for this seller and timeslot
    #[msg("Supply already committed for this seller and timeslot")]
    DuplicateSupply,

    /// Timeslot is not active or invalid
    #[msg("Timeslot is not active or has expired")]
    InvalidTimeslot,

    /// Seller does not have enough tokens to commit supply
    #[msg("Insufficient token balance to commit supply")]
    InsufficientBalance,

    /// Overflow or underflow during arithmetic
    #[msg("Math overflow/underflow error")]
    MathError,

    /// Provided escrow vault PDA does not match expected PDA
    #[msg("Invalid escrow vault account")]
    InvalidEscrowVault,

    /// Unauthorized signer tried to call this instruction
    #[msg("Unauthorized signer for this transaction")]
    Unauthorized,

    /// Global state account mismatch
    #[msg("Invalid global state account provided")]
    InvalidGlobalState,

    /// General constraint violation
    #[msg("Account constraint violated")]
    ConstraintViolation,
}
